name: Build Augment Injector Release

on:
  workflow_dispatch: {}
  schedule:
    - cron: '0 */2 * * *'

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate resources
        run: |
          echo "ðŸ” Validating required resources..."
          
          # Check required JS files
          for file in interceptor.js token-login-enhanced.js augment-balance-enhanced.js; do
            if [ ! -f "resources/$file" ]; then
              echo "âŒ Missing required file: resources/$file"
              exit 1
            fi
            echo "âœ… Found: resources/$file"
          done
          
          # Check required config files
          for file in package-json-commands.json balance-package-commands.json README.md; do
            if [ ! -f "resources/$file" ]; then
              echo "âŒ Missing required file: resources/$file"
              exit 1
            fi
            echo "âœ… Found: resources/$file"
          done
          
          echo "âœ… All required resources validated"

      - name: Download Latest VSIX
        run: |
          echo "ðŸ“¥ Downloading latest Augment VSIX..."
          PUBLISHER="augment"
          EXTENSION_NAME="vscode-augment"
          VSIX_URL="https://marketplace.visualstudio.com/_apis/public/gallery/publishers/${PUBLISHER}/vsextensions/${EXTENSION_NAME}/latest/vspackage"
          
          curl -L --compressed -o original.vsix "$VSIX_URL"
          
          # Verify download
          if [ ! -f "original.vsix" ]; then
            echo "âŒ Failed to download VSIX"
            exit 1
          fi
          
          echo "âœ… VSIX downloaded successfully"
          file original.vsix || true

      - name: Extract VSIX
        run: |
          echo "ðŸ“¦ Extracting VSIX..."
          mkdir -p unpacked_ext
          cd unpacked_ext
          unzip -q ../original.vsix
          cd ..
          echo "âœ… VSIX extracted"

      - name: Get version from package.json
        id: get_version
        run: |
          # Find package.json in unpacked extension
          if [ -f "unpacked_ext/package.json" ]; then
            PKG_PATH="unpacked_ext/package.json"
          elif [ -f "unpacked_ext/extension/package.json" ]; then
            PKG_PATH="unpacked_ext/extension/package.json"
          else
            echo "âŒ package.json not found"
            exit 1
          fi
          
          VERSION=$(python3 -c "import json; print(json.load(open('$PKG_PATH'))['version'])")
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Found version: $VERSION"

      - name: Check if version already released
        id: version_check
        run: |
          git fetch --tags --force --quiet
          TAG_NAME="v${{ env.VERSION }}-triple"
          if git tag -l | grep -q "^${TAG_NAME}$"; then
            echo "skip_build=true" >> $GITHUB_OUTPUT
            echo "Tag ${TAG_NAME} already exists, skipping build"
          else
            echo "skip_build=false" >> $GITHUB_OUTPUT
            echo "Tag ${TAG_NAME} does not exist, proceeding with build"
          fi

      - name: Skip build notification
        if: steps.version_check.outputs.skip_build == 'true'
        run: |
          echo "âœ… Version ${{ env.VERSION }} already released (triple). Skipping packaging and release."

      - name: Perform Triple Injection
        if: steps.version_check.outputs.skip_build == 'false'
        run: |
          echo "ðŸš€ Performing triple injection..."
          
          python3 << 'EOF'
          import os, sys, shutil, json, re, stat
          from pathlib import Path
          from datetime import datetime

          def log(msg):
              print(f"[INFO] {msg}")

          def error(msg):
              print(f"[ERROR] {msg}")
              sys.exit(1)

          # Find extension.js file
          def find_extension_js(base_dir):
              candidates = [
                  base_dir / 'extension' / 'out' / 'extension.js',
                  base_dir / 'extension' / 'dist' / 'extension.js', 
                  base_dir / 'out' / 'extension.js',
                  base_dir / 'dist' / 'extension.js',
                  base_dir / 'extension.js'
              ]
              
              for candidate in candidates:
                  if candidate.exists():
                      return candidate, candidate.parent
              return None, None

          # Inject at head with proper formatting (like local PowerShell script)
          def inject_head(js_file, inject_content, tag):
              log(f"Injecting {tag} at head...")
              content = js_file.read_text(encoding='utf-8')
              
              # Remove existing injection if present
              pattern = rf"// === {re.escape(tag)} Start ===.*?// === {re.escape(tag)} End ===\s*"
              content = re.sub(pattern, '', content, flags=re.DOTALL)
              
              # Create injection with proper formatting (like PowerShell script)
              timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
              injection = f"// === {tag} Start ===\n"
              injection += f"// æ³¨å…¥æ—¶é—´: {timestamp}\n"
              injection += f"// æ³¨å…¥ç‰ˆæœ¬: 1.0\n"
              injection += "!function(){\n"
              injection += '"use strict";\n'
              injection += inject_content + "\n"
              injection += "}();\n"
              injection += f"// === {tag} End ===\n\n"
              
              js_file.write_text(injection + content, encoding='utf-8')
              return True

          # Inject at tail with proper formatting
          def inject_tail(js_file, inject_content, tag):
              log(f"Injecting {tag} at tail...")
              content = js_file.read_text(encoding='utf-8')
              
              # Remove existing injection if present
              pattern = rf"// === {re.escape(tag)} Start ===.*?// === {re.escape(tag)} End ===\s*"
              content = re.sub(pattern, '', content, flags=re.DOTALL)
              
              # Create injection with proper formatting
              timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
              injection = f"\n\n// === {tag} Start ===\n"
              injection += f"// æ³¨å…¥æ—¶é—´: {timestamp}\n"
              injection += "!function(){\n"
              injection += '"use strict";\n'
              injection += inject_content + "\n"
              injection += "}();\n"
              injection += f"// === {tag} End ==="
              
              js_file.write_text(content + injection, encoding='utf-8')
              return True

          try:
              # Find extension.js
              unpacked = Path('unpacked_ext')
              js_path, js_dir = find_extension_js(unpacked)
              
              if not js_path:
                  error("extension.js not found!")
              
              log(f"Found extension.js: {js_path}")
              
              # Fix file permissions (files from ZIP might be read-only)
              js_path.chmod(stat.S_IWRITE | stat.S_IREAD)
              log("File permissions fixed")
              
              # Read injection files
              resources = Path('resources')
              interceptor_content = (resources / 'interceptor.js').read_text(encoding='utf-8')
              token_content = (resources / 'token-login-enhanced.js').read_text(encoding='utf-8')
              balance_content = (resources / 'augment-balance-enhanced.js').read_text(encoding='utf-8')
              
              # Copy module files to extension directory
              shutil.copy(resources / 'token-login-enhanced.js', js_dir / 'token-login-enhanced.js')
              shutil.copy(resources / 'augment-balance-enhanced.js', js_dir / 'augment-balance-enhanced.js')
              log("Module files copied")
              
              # Perform triple injection
              inject_head(js_path, interceptor_content, 'Augment Interceptor Injection')
              inject_tail(js_path, token_content, 'Augment Token Login Enhanced Injection')  
              inject_tail(js_path, balance_content, 'Augment Balance Enhanced Injection')
              
              log("âœ… Triple injection completed successfully")
              
          except Exception as e:
              error(f"Injection failed: {e}")
          EOF

      - name: Update package.json commands
        if: steps.version_check.outputs.skip_build == 'false'
        run: |
          echo "ðŸ“ Updating package.json commands..."

          python3 << 'EOF'
          import json
          from pathlib import Path

          def log(msg):
              print(f"[INFO] {msg}")

          try:
              # Find package.json
              unpacked = Path('unpacked_ext')
              pkg_candidates = [
                  unpacked / 'extension' / 'package.json',
                  unpacked / 'package.json'
              ]

              pkg_path = None
              for candidate in pkg_candidates:
                  if candidate.exists():
                      pkg_path = candidate
                      break

              if not pkg_path:
                  raise FileNotFoundError("package.json not found")

              log(f"Found package.json: {pkg_path}")

              # Load package.json
              with open(pkg_path, 'r', encoding='utf-8') as f:
                  pkg_data = json.load(f)

              # Load command updates
              resources = Path('resources')

              # Update package.json commands
              with open(resources / 'package-json-commands.json', 'r', encoding='utf-8') as f:
                  pkg_commands = json.load(f)

              if 'contributes' not in pkg_data:
                  pkg_data['contributes'] = {}
              if 'commands' not in pkg_data['contributes']:
                  pkg_data['contributes']['commands'] = []

              # Add new commands
              for cmd in pkg_commands.get('commands', []):
                  # Check if command already exists
                  exists = any(existing['command'] == cmd['command']
                             for existing in pkg_data['contributes']['commands'])
                  if not exists:
                      pkg_data['contributes']['commands'].append(cmd)
                      log(f"Added command: {cmd['command']}")

              # Update balance package commands
              with open(resources / 'balance-package-commands.json', 'r', encoding='utf-8') as f:
                  balance_commands = json.load(f)

              # Add balance commands
              for cmd in balance_commands.get('commands', []):
                  exists = any(existing['command'] == cmd['command']
                             for existing in pkg_data['contributes']['commands'])
                  if not exists:
                      pkg_data['contributes']['commands'].append(cmd)
                      log(f"Added balance command: {cmd['command']}")

              # Save updated package.json
              with open(pkg_path, 'w', encoding='utf-8') as f:
                  json.dump(pkg_data, f, indent=2, ensure_ascii=False)

              log("âœ… package.json commands updated successfully")

          except Exception as e:
              print(f"[ERROR] Failed to update package.json: {e}")
              exit(1)
          EOF

      - name: Create README
        if: steps.version_check.outputs.skip_build == 'false'
        run: |
          echo "ðŸ“„ Creating README..."

          # Find the correct location for README.md
          if [ -d "unpacked_ext/extension" ]; then
            # If extension directory exists, put README there
            cp resources/README.md unpacked_ext/extension/README.md
            echo "âœ… README created in extension directory"
          else
            # Otherwise put in root
            cp resources/README.md unpacked_ext/README.md
            echo "âœ… README created in root directory"
          fi

      - name: Package VSIX
        if: steps.version_check.outputs.skip_build == 'false'
        run: |
          echo "ðŸ“¦ Packaging modified VSIX..."
          cd unpacked_ext
          zip -r ../augment.vscode-augment-${{ env.VERSION }}-triple.vsix . -x "*.DS_Store" "*.git*"
          cd ..
          echo "âœ… VSIX packaged"

      - name: Create Release
        if: steps.version_check.outputs.skip_build == 'false'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.VERSION }}-triple
          name: Augment VSCode Extension v${{ env.VERSION }} (Triple Injected)
          body: |
            # Augment VSCode Extension v${{ env.VERSION }} - Triple Injected Version

            ## ðŸš€ Features
            - **Triple Injection**: Interceptor + Token Login + Balance Enhanced
            - **Session Management**: Advanced session handling and spoofing
            - **Request Interception**: Comprehensive HTTP/HTTPS request modification
            - **Balance Enhancement**: Enhanced balance display and management

            ## ðŸ“¥ Installation
            1. Download the `.vsix` file from this release
            2. Open VS Code
            3. Go to Extensions (Ctrl+Shift+X)
            4. Click the "..." menu and select "Install from VSIX..."
            5. Select the downloaded file

            ## ðŸ”§ Technical Details
            - **Base Version**: v${{ env.VERSION }}
            - **Injection Type**: Triple (Head + Tail + Tail)
            - **Build Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
            - **Auto-built**: Yes (GitHub Actions)

            ---
            *This release was automatically generated from the latest marketplace version.*
          files: |
            augment.vscode-augment-${{ env.VERSION }}-triple.vsix
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Success notification
        if: steps.version_check.outputs.skip_build == 'false'
        run: |
          echo "ðŸŽ‰ Build and release completed successfully!"
          echo "ðŸ“¦ Released: augment.vscode-augment-${{ env.VERSION }}-triple.vsix"
          echo "ðŸ·ï¸  Tag: v${{ env.VERSION }}-triple"
